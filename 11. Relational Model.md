## RELATIONAL LANGUAGES
A data model is a collection of conceptual tools for describing data, data relationships, data semantics, and consistency constraints. The relational model uses a collection of tables to represent both data and the relationships among those data. The
relational model describes data at the logical and view levels, abstracting away low-level details of data storage.  
&nbsp;&nbsp;&nbsp;&nbsp;To make data from a relational database available to users, we have to address how users specify requests for retrieving and updating data. Several query languages have been developed for this task.

### Introduction to the Relational Model 
The relational model remains the primary data model for commercial data-processing applications. It attained its primary position because of its simplicity, which eases the job of the programmer, compared to earlier data models such as the network model or the hierarchical model. It has retained this position by incorporating various new features and capabilities over its half-century of existence. Among those additions are object-relational features such as complex data types and stored procedures, support for XML data, and various tools to support semi-structured data.  
&nbsp;&nbsp;&nbsp;&nbsp;The relational model's independence from any specific underlying low-level data structures has allowed it to persist despite the advent of new approaches to data storage, including modern column-stores that are designed for large-scale data mining.

### Structure of Relational Databases:
A relational database consists of a collection of **tables**, each of which is assigned a unique name.  
&nbsp;&nbsp;&nbsp;&nbsp;In general, a row in a table represents a *relationship* among a set of values. Since a table is a collection of such relationships, there is a close correspondence between the concept of *table* and the mathematical concept of *relation*, from which the relational data model takes its name.  
&nbsp;&nbsp;&nbsp;&nbsp;In the relational model the term **relation** is used to refer to a table, while the term **tuple** is used to refer to a row. Similarly, the term **attribute** refers to a column of a table.  
&nbsp;&nbsp;&nbsp;&nbsp;We use the term **relation instance** to refer to a specific instance of a relation, that is, containing a specific set of rows.  
The order in which tuples appear in a relation is irrelevant, since a relation is a set of tuples. Thus, whether the tuples of a relation are listed in sorted order does not matter. For ease of exposition, we generally show the relations sorted by their first attribute.  

#### Domain:
For each attribute of a relation, there is a set of permitted values, called the **domain** of that attribute.  
&nbsp;&nbsp;&nbsp;&nbsp;We require that, for all relations *r*, the domains of all attributes of *r* be atomic. A domain is **atomic** if elements of the domain are considered to be indivisible and treated as a single, irreducible unit by the database system.

### Examples: Atomic vs. Non-Atomic Domains in Database Design:
#### Atomic Domains (Good Practice):
Values are single, indivisible units that can be queried directly.

#### Users Table with Atomic Design:
| UserID | FirstName | LastName | Age | Email |
|--------|-----------|----------|-----|-------|
| 101 | `"Alice"` | `"Smith"` | `28` | `"alice.smith@email.com"` |
| 102 | `"Bob"` | `"Jones"` | `35` | `"bob.jones@email.com"` |
| 103 | `"Carol"` | `"Davis"` | `42` | `"carol.d@email.com"` |

#### Why This is Atomic:
- **FirstName**: Single piece of information (indivisible name)
- **LastName**: Single piece of information (indivisible name)  
- **Age**: Single integer value
- **Email**: Single email address string

#### Non-Atomic Domains (Violates 1NF):
Values contain multiple pieces of information combined into one field.

#### Users Table with Non-Atomic Design:
| UserID | FullName | ContactInfo | PhoneNumbers | Address |
|--------|----------|-------------|--------------|---------|
| 101 | `"Alice Smith"` | `"alice.smith@email.com, 28 years"` | `"555-1234, 555-5678"` | `"123 Main St, Springfield, IL, 62701"` |
| 102 | `"Bob Jones"` | `"bob.jones@email.com, 35 years"` | `"555-9012"` | `"456 Oak Ave, Metropolis, NY, 10001"` |
| 103 | `"Carol Davis"` | `"carol.d@email.com, 42 years"` | `"555-3456, 555-7890, 555-1111"` | `"789 Pine Rd, Gotham, NJ, 07001"` |

#### Why This is Non-Atomic:
- **FullName**: Combines first and last name.
- **ContactInfo**: Combines email and age.
- **PhoneNumbers**: Contains multiple phone numbers in one field.

#### Summary Comparison Table:

| Aspect | Atomic Design | Non-Atomic Design |
|--------|---------------|-------------------|
| **Normalization** | ✅ Complies with 1st Normal Form (1NF) | ❌ Violates 1st Normal Form (1NF) |
| **Query Performance** | ✅ Fast, simple queries with direct filtering | ❌ Slow, requires complex pattern matching (LIKE, SUBSTRING) |
| **Data Integrity** | ✅ Easy to enforce constraints (NOT NULL, UNIQUE, CHECK) | ❌ Difficult or impossible to enforce data validation rules |
| **Update Operations** | ✅ Simple, direct updates to single values | ❌ Complex string manipulation required for updates |
| **Indexing Efficiency** | ✅ Effective indexing on atomic columns | ❌ Poor indexing performance on combined fields |
| **Data Retrieval** | ✅ Direct access to individual data elements | ❌ Requires parsing and extraction from combined fields |
| **Reporting & Analysis** | ✅ Easy grouping, sorting, and aggregation | ❌ Complex data extraction needed for basic reports |
| **Storage Efficiency** | ✅ Optimized storage for each data type | ❌ Potential wasted space from combined text fields |
| **Scalability** | ✅ Scales well with growing data volume | ❌ Performance degrades significantly with size |
| **Maintenance** | ✅ Easy schema changes and data migration | ❌ Difficult to modify structure without data loss |
| **Data Validation** | ✅ Type-safe validation per column | ❌ Mixed data types in single columns |
| **Foreign Key Relationships** | ✅ Clean relationships between tables | ❌ Difficult to establish proper relationships |

### Practical Examples Comparison (Querying for Specific Data):
1. **Atomic Design:**
```sql
-- Simple and efficient
SELECT * FROM Users WHERE LastName = 'Smith';
SELECT * FROM Users WHERE Age > 30 AND City = 'New York';
```
2. **Non-Atomic Design:**
```sql
-- Complex and inefficient
SELECT * FROM Users WHERE FullName LIKE '% Smith%';
SELECT * FROM Users WHERE ContactInfo LIKE '%NY%' AND ContactInfo LIKE '%30%';
```
Atomicity is the first rule of the **First Normal Form (1NF)**, which is the foundation for a well-structured relational database. The important issue is not what the domain itself is, but rather how we use domain elements in our database.

#### NULL Value:
The **null value** is a special value that signifies that the value is unknown or does not exist. NULL values cause a number of difficulties when we access or update the database, and thus they should be eliminated if at all possible.  
&nbsp;&nbsp;&nbsp;&nbsp;The relatively strict structure of relations results in several important practical advantages in the storage and processing of data. That strict structure is suitable for well defined and relatively static applications, but it is less suitable for applications where not only data but also the types and structure of those data change over time. A modern enterprise needs to find a good balance between the efficiencies of structured data and those situations where a predetermined structure is limiting.
