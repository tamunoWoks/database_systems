## Keys
In a relational database, **keys** are attributes (columns) or sets of attributes that are used to *uniquely identify* records within a table and to establish relationships between tables. They are fundamental to the structure, integrity, and power of a relational database. Think of them as the **unique identifiers** and **connectors** that give meaning to your data.

#### The Core Purpose of Keys:
Keys serve two primary functions:
1. **Uniquely Identify Records:** To ensure each row in a table can be distinguished from all others.
2. **Establish Relationships:** To link data in one table to data in another table.

### Superkey:
A **superkey** is a set of one or more columns (attributes) in a database table that can be used to uniquely identify each row in that table. Think of it as any combination of columns that guarantees uniqueness for every record.  
&nbsp;&nbsp;&nbsp;&nbsp;For example, the `ID` attribute of the relation `student` is sufficient to distinguish one student tuple from another. Thus, `ID` is a superkey. The `name` attribute of `student`, on the other hand, is not a superkey, because several students might have the same name.  

A superkey is just a broad definition for uniqueness. It might contain more columns than are necessary, but if you can look at the values in a set of columns and always point to exactly one row, that set of columns is a superkey.

#### Examples:
Let's use a Students table:

| StudentID | Email | CourseCode | YearEnrolled |
|-----------|-------------------|------------|--------------|
| 101 | `alice@school.edu` | CS101 | 2023 |
| 102 | `bob@school.edu` | CS101 | 2023 |
| 103 | `alice@school.edu` | MA202 | 2022 |

Which combinations are superkeys? (i.e., which combinations are unique for each row?)

| Combination | Unique? | Superkey? | Reason |
|-------------|---------|-----------|---------|
| `{StudentID}` | ✅ Yes | ✅ Yes | 101, 102, 103 are all different |
| `{StudentID, Email}` | ✅ Yes | ✅ Yes | Contains StudentID which is already unique |
| `{Email}` | ❌ No | ❌ No | `alice@school.edu` appears twice |
| `{Email, CourseCode}` | ✅ Yes | ✅ Yes | Each combination appears only once |
| `{StudentID, Email, CourseCode}` | ✅ Yes | ✅ Yes | Contains StudentID which is already unique |

### Candidate Key:
A **candidate key** is a minimal superkey, a set of one or more columns that uniquely identifies each row in a table, and from which you cannot remove any column without destroying its uniqueness. Think of it as the shortest possible unique identifier for a table.  
The key idea is that a candidate key must satisfy two conditions:
1. **Uniqueness:** It must uniquely identify each row (like any superkey).
2. **Irreducibility (Minimality):** It must contain no unnecessary columns. If you remove any column from it, it would no longer be unique.

#### Examples:
Let's use a Students table:
| StudentID | NationalID | Email | CourseCode | YearEnrolled |
|-----------|------------|-------------------|------------|--------------|
| 101 | N12345 | `alice@school.edu` | CS101 | 2023 |
| 102 | N67890 | `bob@school.edu` | CS101 | 2023 |
| 103 | N12345 | `alice@school.edu` | MA202 | 2022 |

Let's evaluate different column sets:
| Column Set | Unique? | Minimal? | Type of Key |
|------------|---------|----------|-------------|
| `{StudentID}` | ✅ Yes | ✅ Yes | **Candidate Key** |
| `{NationalID}` | ❌ No | ❌ No | Not a superkey (duplicate N12345) |
| `{Email}` | ❌ No | ❌ No | Not a superkey (duplicate email) |
| `{StudentID, Email}` | ✅ Yes | ❌ No | Superkey (not minimal - Email is extra) |
| `{NationalID, CourseCode}` | ✅ Yes | ✅ Yes | **Candidate Key** |
| `{Email, CourseCode}` | ✅ Yes | ✅ Yes | **Candidate Key** |
| `{StudentID, NationalID, Email}` | ✅ Yes | ❌ No | Superkey (not minimal - has extra columns) |

#### Properties of Candidate Keys:
| Property | Description | Why it Matters |
|----------|-------------|----------------|
| **Uniqueness** | Each candidate key value must identify exactly one row | Prevents duplicate records |
| **Minimality** | Cannot remove any column without losing uniqueness | Ensures efficiency and simplicity |
| **Non-redundancy** | No attribute in the key can be NULL (theoretically) | Maintains data integrity |
| **Stability** | Values should not change frequently | Prevents cascading updates |

### Primary Key:
A **primary key** is a specific column, or a set of columns, in a database table that *uniquely identifies each individual record (row)* in that table. It is the main *unique identifier* for a table and is the most important type of key. Think of it as a unique fingerprint for every row of data.  
The primary key's main job is to enforce entity integrity, ensuring that every record in the table is unique and can be reliably identified and referenced.  

For a field (or set of fields) to be a primary key, it must adhere to two strict rules:
1. **Unique:** No two rows in the table can have the same primary key value.
2. **NOT NULL:** The primary key field **must always have a value**. It cannot be empty or unknown (NULL).

#### Types of Primary Keys:
1. **Natural Key:** Uses a pre-existing, unique piece of data that has meaning in the real world. It is meaningful, but it can change or might not be truly unique. Eg. `SocialSecurityNumber`, `EmailAddress`, `ISBN` for a book.
2. **Surrogate Key:** A system-generated, artificial key with no business meaning. Its only purpose is to be a unique identifier. it is guaranteed to be unique, stable, never changes, but it can be meaningless to users. Eg. An auto-incrementing number (`1`, `2`, `3...`), a `GUID/UUID`. 

Surrogate keys (like auto-incrementing integers) are extremely common in modern database design because of their simplicity and reliability.

#### Examples:
Let's look at a `Customers` table where `CustomerID` is the primary key.
| CustomerID (PK) | FirstName | LastName | Email |
|-----------------|-----------|----------|-----------------------|
| **C101** | Alice | Smith | alice@email.com |
| **C102** | Bob | Jones | bob.j@email.com |
| **C103** | Charlie | Brown | cbrown@email.com |

- The CustomerID column is the primary key.
- Notice that every value in this column is unique and not empty.

#### Summary:
| Aspect | Primary Key |
|--------|-------------|
| **Purpose** | To be the main, unique identifier for every record in a table. |
| **Number per Table** | Exactly **one**. |
| **Mandatory Rules** | **Unique** and **NOT NULL**. |
| **Main Benefit** | Uniquely identifies records and enables relationships between tables via foreign keys. |

#### Note:
- It is customary to list the primary key attributes of a relation schema before the other attributes.
- Primary keys must be chosen with care. As we noted, the name of a person is insufficient, because there may be many people with the same name.
- An alternative is to use some unique combination of other attributes as a key.
- The primary key should be chosen such that its attribute values are never, or are very rarely, changed. For instance, the address field of a person should not be part of the primary key, since it is likely to change.

### Foreign Keys:
A **foreign key** is a column (or set of columns) in one table that uniquely identifies a row in another table. It creates a link between two tables by referencing the primary key of another table. Think of it as a pointer or a cross-reference that establishes a relationship between two tables.  

The main job of a foreign key is to enforce **referential integrity**, which ensures that relationships between tables remain consistent. It prevents actions that would create orphaned records (records that point to non-existent data).

#### Example:
Let's see how a foreign key connects two tables.

Table 1: Departments (Parent Table)
| DepartmentID (PK) | DepartmentName | Manager |
|-------------------|----------------|---------|
| **D100** | Engineering | Alice Chen |
| **D200** | Sales | Bob Smith |
| **D300** | Marketing | Carol Davis |

Table 2: Employees (Child Table)
| EmployeeID (PK) | FirstName | LastName | DepartmentID (FK) |
|-----------------|-----------|----------|-------------------|
| E001 | John | Doe | **D100** |
| E002 | Jane | Smith | **D200** |
| E003 | Mike | Johnson | **D100** |
| E004 | Sarah | Wilson | **NULL** |

Relationship Explained:
- DepartmentID is the primary key (PK) in the Departments table.
- DepartmentID is the foreign key (FK) in the Employees table.
- John Doe (E001) works in the Engineering department (D100).
- Sarah Wilson (E004) is not currently assigned to any department (NULL).

#### Foreign Key Constraints and Actions:
Foreign keys can enforce specific behaviors when the referenced data is updated or deleted:
| Action | Description | Example |
|--------|-------------|---------|
| **RESTRICT** | Prevents the action if related records exist. | Cannot delete a department that has employees. |
| **CASCADE** | Automatically performs the same action on related records. | Deleting a department automatically deletes all its employees. |
| **SET NULL** | Sets the foreign key value to NULL in related records. | Deleting a department sets DepartmentID to NULL for its employees. |
| **SET DEFAULT** | Sets the foreign key value to a default value in related records. | Deleting a department sets DepartmentID to a default "Unassigned" value. |
| **NO ACTION** | Similar to RESTRICT; checks constraints after the operation. | Database throws an error after attempting to delete. |

#### Why are Foreign Keys So Important?:
1. **Data Consistency**: Prevents invalid data from being entered. You cannot have an employee in a non-existent department.
2. **Relationship Mapping**: Creates clear, enforceable relationships between tables (one-to-many, many-to-one).
3. **Cascading Actions**: Automatically maintains consistency when related data changes.
4. **Query Power**: Enables powerful JOIN operations to combine data from multiple tables.
5. **Documentation**: Clearly shows how tables are related just by looking at the schema. 
